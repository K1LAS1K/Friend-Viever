print("Fixed Friend Viewer with Clean GUI v5.0 loaded - Improved Line Management")

local players = game:GetService("Players")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")
local textService = game:GetService("TextService")
local httpService = game:GetService("HttpService")
local cam = workspace.CurrentCamera
local localPlayer = players.LocalPlayer
local drawing = Drawing.new

-- Enhanced Configuration
local config = {
    threshold = 25,
    maxRenderDistance = 500,
    updateRate = 0.1,  -- Back to reasonable update rate
    lineThickness = 2,
    dotRadius = 8,
    textSize = 16,
    animationSpeed = 0.5,
    maxConnections = 30,  -- Reasonable connection limit
    guiKeybind = Enum.KeyCode.Insert,
    maxVisibleFriends = 4,  -- Maximum friends to show without scrolling
    lineDuration = 0.3  -- Shorter duration but visible
}

-- State Management
local state = {
    linesEnabled = true,
    guiVisible = true,
    friendships = {},
    friendData = {},
    trackedPlayers = {},
    uiElements = {},
    lastUpdate = 0,
    performanceMode = false,
    guiMinimized = false,
    activeConnections = {},  -- Track active drawing connections
    cleanupScheduled = false,
    maxActiveLines = 100,  -- Higher line limit
    currentLineCount = 0,  -- Track current line count
    lastGlobalDraw = 0  -- Global rate limiting
}

-- GUI References
local gui = {
    screenGui = nil,
    mainFrame = nil,
    titleBar = nil,
    contentFrame = nil,
    minimizeButton = nil,
    closeButton = nil,
    friendListFrame = nil,
    toggleButton = nil,
    statusLabel = nil
}

-- UI Elements Storage with persistent elements
local ui = {
    lines = {},
    dots = {},
    texts = {},
    healthBars = {},
    connections = {},  -- Track RunService connections
    persistentLines = {},  -- Store persistent line objects by friendship key
    persistentDots = {}    -- Store persistent dot objects by player
}

-- Enhanced Cleanup Function for Persistent Elements
local function cleanupDrawingElements()
    -- Clean up persistent lines
    for key, lineData in pairs(ui.persistentLines) do
        if lineData.line then
            pcall(function()
                lineData.line:Remove()
            end)
        end
        ui.persistentLines[key] = nil
    end
    
    -- Clean up persistent dots
    for key, dotData in pairs(ui.persistentDots) do
        if dotData.dot then
            pcall(function()
                dotData.dot:Remove()
            end)
        end
        ui.persistentDots[key] = nil
    end
    
    -- Clean up temporary elements
    for elementType, elementList in pairs(ui) do
        if elementType ~= "connections" and elementType ~= "persistentLines" and elementType ~= "persistentDots" then
            for i = #elementList, 1, -1 do
                local element = elementList[i]
                if element then
                    pcall(function()
                        if element.Remove then
                            element:Remove()
                        end
                    end)
                end
                elementList[i] = nil
            end
            ui[elementType] = {}
        end
    end
    
    -- Reset counters
    state.currentLineCount = 0
    state.lastGlobalDraw = 0
    
    -- Force garbage collection
    pcall(function()
        collectgarbage("collect")
    end)
    
    state.cleanupScheduled = false
    print("Persistent drawing elements cleaned up")
end

-- Schedule cleanup to prevent memory leaks
local function scheduleCleanup()
    if not state.cleanupScheduled then
        state.cleanupScheduled = true
        task.wait(config.updateRate)
        cleanupDrawingElements()
    end
end

-- Utility Functions
local function createUIElement(elementType, properties)
    local element = drawing(elementType)
    for prop, value in pairs(properties) do
        pcall(function()
            element[prop] = value
        end)
    end
    return element
end

local function getDistanceColor(distance)
    local normalizedDistance = math.clamp(1 / (distance / config.threshold), 0, 1)
    return Color3.fromRGB(255, 0, 0):Lerp(Color3.fromRGB(0, 255, 0), normalizedDistance)
end

local function formatDistance(distance)
    if distance < 10 then
        return string.format("%.1f", distance)
    else
        return string.format("%.0f", distance)
    end
end

local function getPlayerThumbnail(userId)
    local success, result = pcall(function()
        return players:GetUserThumbnailAsync(userId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150)
    end)
    return success and result or "rbxasset://textures/ui/GuiImagePlaceholder.png"
end

local function analyzeFriendship(p1, p2)
    local data = {
        player1 = p1,
        player2 = p2,
        distance = 0,
        isClose = false,
        isOnline = true
    }
    
    if p1.Character and p2.Character and 
       p1.Character:FindFirstChild("HumanoidRootPart") and 
       p2.Character:FindFirstChild("HumanoidRootPart") then
        
        local pos1 = p1.Character.HumanoidRootPart.Position
        local pos2 = p2.Character.HumanoidRootPart.Position
        data.distance = (pos1 - pos2).Magnitude
        data.isClose = data.distance < config.threshold
    end
    
    return data
end

-- Smooth Persistent Line Drawing System
local function updateConnection(p1, p2, friendshipKey)
    if not state.linesEnabled then 
        -- Hide existing line if lines are disabled
        if ui.persistentLines[friendshipKey] then
            ui.persistentLines[friendshipKey].line.Visible = false
        end
        return 
    end
    
    if not p1 or not p2 then return end
    if not p1.Character or not p2.Character then return end
    if not p1.Character:FindFirstChild("HumanoidRootPart") or not p2.Character:FindFirstChild("HumanoidRootPart") then return end
    
    local p1Pos = p1.Character.HumanoidRootPart.Position
    local p2Pos = p2.Character.HumanoidRootPart.Position
    local distance = (p1Pos - p2Pos).Magnitude
    
    -- Basic distance check
    if distance > config.maxRenderDistance then 
        if ui.persistentLines[friendshipKey] then
            ui.persistentLines[friendshipKey].line.Visible = false
        end
        return 
    end
    
    local p1Screen, vis1 = cam:WorldToViewportPoint(p1Pos)
    local p2Screen, vis2 = cam:WorldToViewportPoint(p2Pos)
    
    -- Handle behind camera cases
    if p1Screen.Z < 0 then
        p1Screen = Vector3.new(cam.ViewportSize.X - p1Screen.X, cam.ViewportSize.Y - p1Screen.Y, 1)
        vis1 = false
    end
    if p2Screen.Z < 0 then
        p2Screen = Vector3.new(cam.ViewportSize.X - p2Screen.X, cam.ViewportSize.Y - p2Screen.Y, 1)
        vis2 = false
    end
    
    -- Only proceed if at least one player is visible
    if not vis1 and not vis2 then 
        if ui.persistentLines[friendshipKey] then
            ui.persistentLines[friendshipKey].line.Visible = false
        end
        return 
    end
    
    local p1Vec2 = Vector2.new(p1Screen.X, p1Screen.Y)
    local p2Vec2 = Vector2.new(p2Screen.X, p2Screen.Y)
    local color = getDistanceColor(distance)
    
    -- Create or update persistent line
    if not ui.persistentLines[friendshipKey] then
        -- Create new persistent line
        local success, line = pcall(function()
            return createUIElement("Line", {
                From = p1Vec2,
                To = p2Vec2,
                Color = color,
                Thickness = config.lineThickness,
                Transparency = 0.3,
                Visible = true
            })
        end)
        
        if success and line then
            ui.persistentLines[friendshipKey] = {
                line = line,
                lastUpdate = tick()
            }
            state.currentLineCount = state.currentLineCount + 1
        end
    else
        -- Update existing line position and properties
        local lineData = ui.persistentLines[friendshipKey]
        if lineData.line then
            pcall(function()
                lineData.line.From = p1Vec2
                lineData.line.To = p2Vec2
                lineData.line.Color = color
                lineData.line.Visible = true
                lineData.lastUpdate = tick()
            end)
        end
    end
    
    -- Update or create persistent dots
    local p1Key = p1.Name .. "_dot"
    local p2Key = p2.Name .. "_dot"
    
    if vis1 then
        if not ui.persistentDots[p1Key] then
            local success, dot1 = pcall(function()
                return createUIElement("Circle", {
                    Position = p1Vec2,
                    Color = Color3.fromRGB(100, 200, 255),
                    Thickness = 2,
                    Radius = config.dotRadius,
                    Filled = true,
                    NumSides = 20,
                    Transparency = 0.2,
                    Visible = true
                })
            end)
            
            if success and dot1 then
                ui.persistentDots[p1Key] = {
                    dot = dot1,
                    player = p1
                }
            end
        else
            -- Update existing dot position
            local dotData = ui.persistentDots[p1Key]
            if dotData.dot then
                pcall(function()
                    dotData.dot.Position = p1Vec2
                    dotData.dot.Visible = true
                end)
            end
        end
    end
    
    if vis2 then
        if not ui.persistentDots[p2Key] then
            local success, dot2 = pcall(function()
                return createUIElement("Circle", {
                    Position = p2Vec2,
                    Color = Color3.fromRGB(100, 200, 255),
                    Thickness = 2,
                    Radius = config.dotRadius,
                    Filled = true,
                    NumSides = 20,
                    Transparency = 0.2,
                    Visible = true
                })
            end)
            
            if success and dot2 then
                ui.persistentDots[p2Key] = {
                    dot = dot2,
                    player = p2
                }
            end
        else
            -- Update existing dot position
            local dotData = ui.persistentDots[p2Key]
            if dotData.dot then
                pcall(function()
                    dotData.dot.Position = p2Vec2
                    dotData.dot.Visible = true
                end)
            end
        end
    end
end

-- Smooth Friendship Tracking with Persistent Lines
local function trackFriendship(p1, p2)
    local key = p1.Name .. "-" .. p2.Name
    if state.trackedPlayers[key] then return end
    
    state.trackedPlayers[key] = true
    
    -- Store friendship data
    local friendshipData = analyzeFriendship(p1, p2)
    state.friendData[key] = friendshipData
    
    local connection
    connection = runService.Heartbeat:Connect(function()
        if not p1.Parent or not p2.Parent then
            -- Clean up when players leave
            connection:Disconnect()
            state.trackedPlayers[key] = nil
            state.friendData[key] = nil
            
            -- Remove persistent line and dots
            if ui.persistentLines[key] then
                pcall(function()
                    ui.persistentLines[key].line:Remove()
                end)
                ui.persistentLines[key] = nil
                state.currentLineCount = math.max(0, state.currentLineCount - 1)
            end
            
            -- Remove player dots
            local p1Key = p1.Name .. "_dot"
            local p2Key = p2.Name .. "_dot"
            if ui.persistentDots[p1Key] then
                pcall(function()
                    ui.persistentDots[p1Key].dot:Remove()
                end)
                ui.persistentDots[p1Key] = nil
            end
            if ui.persistentDots[p2Key] then
                pcall(function()
                    ui.persistentDots[p2Key].dot:Remove()
                end)
                ui.persistentDots[p2Key] = nil
            end
            return
        end
        
        local currentTime = tick()
        
        -- Update friendship data for GUI
        if currentTime - state.lastUpdate >= config.updateRate then
            state.friendData[key] = analyzeFriendship(p1, p2)
        end
        
        -- Update persistent connection lines smoothly
        updateConnection(p1, p2, key)
    end)
    
    -- Track the connection for cleanup
    table.insert(ui.connections, connection)
end

local function scanForFriends()
    local currentPlayers = players:GetPlayers()
    local connectionCount = 0
    
    for i, p1 in ipairs(currentPlayers) do
        if connectionCount >= config.maxConnections then break end
        
        for j = i + 1, #currentPlayers do
            if connectionCount >= config.maxConnections then break end
            
            local p2 = currentPlayers[j]
            
            if p1 == p2 then continue end
            
            local isFriend = false
            pcall(function()
                isFriend = p1:IsFriendsWith(p2.UserId) or p2:IsFriendsWith(p1.UserId)
            end)
            
            if isFriend then
                local friendshipKey = table.concat({p1.Name, p2.Name}, "-")
                local reverseKey = table.concat({p2.Name, p1.Name}, "-")
                
                local alreadyTracked = false
                for _, friendship in ipairs(state.friendships) do
                    if friendship == friendshipKey or friendship == reverseKey then
                        alreadyTracked = true
                        break
                    end
                end
                
                if not alreadyTracked then
                    table.insert(state.friendships, friendshipKey)
                    trackFriendship(p1, p2)
                    connectionCount = connectionCount + 1
                end
            end
        end
    end
end

-- Create Friend Entry with Better Layout
local function createFriendEntry(friendData, parent, yPosition)
    local entryFrame = Instance.new("Frame")
    entryFrame.Name = "FriendEntry"
    entryFrame.Size = UDim2.new(1, -10, 0, 65)
    entryFrame.Position = UDim2.new(0, 5, 0, yPosition)
    entryFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
    entryFrame.BorderSizePixel = 0
    entryFrame.Parent = parent
    
    local entryCorner = Instance.new("UICorner")
    entryCorner.CornerRadius = UDim.new(0, 8)
    entryCorner.Parent = entryFrame
    
    -- Player 1 Image
    local p1Image = Instance.new("ImageLabel")
    p1Image.Name = "Player1Image"
    p1Image.Size = UDim2.new(0, 35, 0, 35)
    p1Image.Position = UDim2.new(0, 10, 0, 15)
    p1Image.BackgroundTransparency = 1
    p1Image.Image = getPlayerThumbnail(friendData.player1.UserId)
    p1Image.Parent = entryFrame
    
    local p1Corner = Instance.new("UICorner")
    p1Corner.CornerRadius = UDim.new(0, 17)
    p1Corner.Parent = p1Image
    
    -- Connection Arrow
    local arrowLabel = Instance.new("TextLabel")
    arrowLabel.Name = "Arrow"
    arrowLabel.Size = UDim2.new(0, 25, 0, 20)
    arrowLabel.Position = UDim2.new(0, 50, 0, 22)
    arrowLabel.BackgroundTransparency = 1
    arrowLabel.Text = "â†”"
    arrowLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
    arrowLabel.TextScaled = true
    arrowLabel.Font = Enum.Font.GothamBold
    arrowLabel.Parent = entryFrame
    
    -- Player 2 Image
    local p2Image = Instance.new("ImageLabel")
    p2Image.Name = "Player2Image"
    p2Image.Size = UDim2.new(0, 35, 0, 35)
    p2Image.Position = UDim2.new(0, 80, 0, 15)
    p2Image.BackgroundTransparency = 1
    p2Image.Image = getPlayerThumbnail(friendData.player2.UserId)
    p2Image.Parent = entryFrame
    
    local p2Corner = Instance.new("UICorner")
    p2Corner.CornerRadius = UDim.new(0, 17)
    p2Corner.Parent = p2Image
    
    -- Friend Info
    local infoLabel = Instance.new("TextLabel")
    infoLabel.Name = "InfoLabel"
    infoLabel.Size = UDim2.new(1, -125, 0, 35)
    infoLabel.Position = UDim2.new(0, 120, 0, 15)
    infoLabel.BackgroundTransparency = 1
    infoLabel.Text = friendData.player1.DisplayName .. " â†” " .. friendData.player2.DisplayName .. "\nDistance: " .. formatDistance(friendData.distance) .. " studs"
    infoLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    infoLabel.TextSize = 12
    infoLabel.Font = Enum.Font.Gotham
    infoLabel.TextXAlignment = Enum.TextXAlignment.Left
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    infoLabel.Parent = entryFrame
    
    -- Status Indicator
    local statusDot = Instance.new("Frame")
    statusDot.Name = "StatusDot"
    statusDot.Size = UDim2.new(0, 10, 0, 10)
    statusDot.Position = UDim2.new(1, -18, 0, 15)
    statusDot.BackgroundColor3 = friendData.isClose and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 165, 0)
    statusDot.BorderSizePixel = 0
    statusDot.Parent = entryFrame
    
    local dotCorner = Instance.new("UICorner")
    dotCorner.CornerRadius = UDim.new(0, 5)
    dotCorner.Parent = statusDot
    
    return entryFrame
end

-- Improved Friend List Update with Better Scrolling
local function updateFriendList()
    if not gui.friendListFrame then return end
    
    -- Clear existing entries
    for _, child in ipairs(gui.friendListFrame:GetChildren()) do
        if child:IsA("ScrollingFrame") then
            for _, entry in ipairs(child:GetChildren()) do
                if entry.Name == "FriendEntry" then
                    entry:Destroy()
                end
            end
        end
    end
    
    -- Create or get scroll frame
    local scrollFrame = gui.friendListFrame:FindFirstChild("FriendScrollFrame")
    if not scrollFrame then
        scrollFrame = Instance.new("ScrollingFrame")
        scrollFrame.Name = "FriendScrollFrame"
        scrollFrame.Size = UDim2.new(1, -5, 1, 0)
        scrollFrame.Position = UDim2.new(0, 0, 0, 0)
        scrollFrame.BackgroundTransparency = 1
        scrollFrame.BorderSizePixel = 0
        scrollFrame.ScrollBarThickness = 8
        scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 150, 200)
        scrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
        scrollFrame.Parent = gui.friendListFrame
        
        -- Add padding
        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 5)
        padding.PaddingBottom = UDim.new(0, 5)
        padding.Parent = scrollFrame
    end
    
    -- Count friends and add entries
    local friendCount = 0
    local yPos = 0
    
    for key, friendData in pairs(state.friendData) do
        if friendData.player1 and friendData.player2 then
            createFriendEntry(friendData, scrollFrame, yPos)
            yPos = yPos + 70
            friendCount = friendCount + 1
        end
    end
    
    -- Update canvas size for scrolling
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, math.max(yPos, 0))
    
    -- Show scroll bar only if needed
    scrollFrame.ScrollBarImageTransparency = friendCount > config.maxVisibleFriends and 0 or 1
    
    return friendCount
end

-- Enhanced GUI Creation with Better Controls
local function createCleanGUI()
    -- Clean up existing GUI
    if gui.screenGui then
        gui.screenGui:Destroy()
    end
    
    -- Main ScreenGui
    gui.screenGui = Instance.new("ScreenGui")
    gui.screenGui.Name = "FriendViewerCleanGUI"
    gui.screenGui.ResetOnSpawn = false
    gui.screenGui.Parent = localPlayer.PlayerGui
    
    -- Main Frame - Centered and resizable
    gui.mainFrame = Instance.new("Frame")
    gui.mainFrame.Name = "MainFrame"
    gui.mainFrame.Size = UDim2.new(0, 550, 0, 450)
    gui.mainFrame.Position = UDim2.new(0.5, -275, 0.5, -225)
    gui.mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    gui.mainFrame.BorderSizePixel = 0
    gui.mainFrame.Active = true
    gui.mainFrame.Draggable = true
    gui.mainFrame.Parent = gui.screenGui
    
    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, 12)
    mainCorner.Parent = gui.mainFrame
    
    -- Shadow effect
    local shadow = Instance.new("Frame")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 10, 1, 10)
    shadow.Position = UDim2.new(0, -5, 0, -5)
    shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    shadow.BackgroundTransparency = 0.7
    shadow.BorderSizePixel = 0
    shadow.ZIndex = -1
    shadow.Parent = gui.mainFrame
    
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 12)
    shadowCorner.Parent = shadow
    
    -- Title Bar
    gui.titleBar = Instance.new("Frame")
    gui.titleBar.Name = "TitleBar"
    gui.titleBar.Size = UDim2.new(1, 0, 0, 50)
    gui.titleBar.Position = UDim2.new(0, 0, 0, 0)
    gui.titleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    gui.titleBar.BorderSizePixel = 0
    gui.titleBar.Parent = gui.mainFrame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 12)
    titleCorner.Parent = gui.titleBar
    
    -- Title Text with "By KILASIK"
    local titleText = Instance.new("TextLabel")
    titleText.Name = "TitleText"
    titleText.Size = UDim2.new(1, -120, 1, 0)
    titleText.Position = UDim2.new(0, 15, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = "ðŸ”— Friend Viewer v5.0 - By KILASIK"
    titleText.TextColor3 = Color3.fromRGB(100, 200, 255)
    titleText.TextScaled = true
    titleText.Font = Enum.Font.GothamBold
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = gui.titleBar
    
    -- Minimize Button
    gui.minimizeButton = Instance.new("TextButton")
    gui.minimizeButton.Name = "MinimizeButton"
    gui.minimizeButton.Size = UDim2.new(0, 35, 0, 35)
    gui.minimizeButton.Position = UDim2.new(1, -85, 0, 7.5)
    gui.minimizeButton.BackgroundColor3 = Color3.fromRGB(255, 193, 7)
    gui.minimizeButton.Text = "_"
    gui.minimizeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    gui.minimizeButton.TextScaled = true
    gui.minimizeButton.Font = Enum.Font.GothamBold
    gui.minimizeButton.BorderSizePixel = 0
    gui.minimizeButton.Parent = gui.titleBar
    
    local minimizeCorner = Instance.new("UICorner")
    minimizeCorner.CornerRadius = UDim.new(0, 6)
    minimizeCorner.Parent = gui.minimizeButton
    
    -- Close Button (X)
    gui.closeButton = Instance.new("TextButton")
    gui.closeButton.Name = "CloseButton"
    gui.closeButton.Size = UDim2.new(0, 35, 0, 35)
    gui.closeButton.Position = UDim2.new(1, -45, 0, 7.5)
    gui.closeButton.BackgroundColor3 = Color3.fromRGB(220, 53, 69)
    gui.closeButton.Text = "X"
    gui.closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    gui.closeButton.TextScaled = true
    gui.closeButton.Font = Enum.Font.GothamBold
    gui.closeButton.BorderSizePixel = 0
    gui.closeButton.Parent = gui.titleBar
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 6)
    closeCorner.Parent = gui.closeButton
    
    -- Content Frame
    gui.contentFrame = Instance.new("Frame")
    gui.contentFrame.Name = "ContentFrame"
    gui.contentFrame.Size = UDim2.new(1, -20, 1, -110)
    gui.contentFrame.Position = UDim2.new(0, 10, 0, 55)
    gui.contentFrame.BackgroundTransparency = 1
    gui.contentFrame.Parent = gui.mainFrame
    
    -- Friend List Title
    local listTitle = Instance.new("TextLabel")
    listTitle.Name = "ListTitle"
    listTitle.Size = UDim2.new(1, 0, 0, 30)
    listTitle.Position = UDim2.new(0, 0, 0, 0)
    listTitle.BackgroundTransparency = 1
    listTitle.Text = "ðŸ‘¥ Active Friendships"
    listTitle.TextColor3 = Color3.fromRGB(100, 200, 255)
    listTitle.TextScaled = true
    listTitle.Font = Enum.Font.GothamBold
    listTitle.TextXAlignment = Enum.TextXAlignment.Left
    listTitle.Parent = gui.contentFrame
    
    -- Friend List Frame
    gui.friendListFrame = Instance.new("Frame")
    gui.friendListFrame.Name = "FriendListFrame"
    gui.friendListFrame.Size = UDim2.new(1, 0, 1, -35)
    gui.friendListFrame.Position = UDim2.new(0, 0, 0, 35)
    gui.friendListFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    gui.friendListFrame.BorderSizePixel = 0
    gui.friendListFrame.Parent = gui.contentFrame
    
    local listCorner = Instance.new("UICorner")
    listCorner.CornerRadius = UDim.new(0, 8)
    listCorner.Parent = gui.friendListFrame
    
    -- Control Panel
    local controlPanel = Instance.new("Frame")
    controlPanel.Name = "ControlPanel"
    controlPanel.Size = UDim2.new(1, 0, 0, 50)
    controlPanel.Position = UDim2.new(0, 0, 1, -60)
    controlPanel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    controlPanel.BorderSizePixel = 0
    controlPanel.Parent = gui.mainFrame
    
    local controlCorner = Instance.new("UICorner")
    controlCorner.CornerRadius = UDim.new(0, 8)
    controlCorner.Parent = controlPanel
    
    -- Enhanced Toggle Button
    gui.toggleButton = Instance.new("TextButton")
    gui.toggleButton.Name = "ToggleButton"
    gui.toggleButton.Size = UDim2.new(0, 140, 0, 35)
    gui.toggleButton.Position = UDim2.new(0, 10, 0, 7.5)
    gui.toggleButton.BackgroundColor3 = Color3.fromRGB(40, 167, 69)
    gui.toggleButton.Text = "âœ“ Lines ON"
    gui.toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    gui.toggleButton.TextScaled = true
    gui.toggleButton.Font = Enum.Font.GothamBold
    gui.toggleButton.BorderSizePixel = 0
    gui.toggleButton.Parent = controlPanel
    
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 6)
    toggleCorner.Parent = gui.toggleButton
    
    -- Discord Button
    local discordButton = Instance.new("TextButton")
    discordButton.Name = "DiscordButton"
    discordButton.Size = UDim2.new(0, 180, 0, 35)
    discordButton.Position = UDim2.new(1, -190, 0, 7.5)
    discordButton.BackgroundColor3 = Color3.fromRGB(114, 137, 218)
    discordButton.Text = "ðŸ“‹ Copy: discord.gg/PHxN8nadgk"
    discordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    discordButton.TextScaled = true
    discordButton.Font = Enum.Font.Gotham
    discordButton.BorderSizePixel = 0
    discordButton.Parent = controlPanel
    
    local discordCorner = Instance.new("UICorner")
    discordCorner.CornerRadius = UDim.new(0, 6)
    discordCorner.Parent = discordButton
    
    -- Enhanced Status Label
    gui.statusLabel = Instance.new("TextLabel")
    gui.statusLabel.Name = "StatusLabel"
    gui.statusLabel.Size = UDim2.new(0, 150, 0, 35)
    gui.statusLabel.Position = UDim2.new(0, 155, 0, 7.5)
    gui.statusLabel.BackgroundTransparency = 1
    gui.statusLabel.Text = "Friends: 0 | Lines: ON"
    gui.statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    gui.statusLabel.TextScaled = true
    gui.statusLabel.Font = Enum.Font.Gotham
    gui.statusLabel.TextXAlignment = Enum.TextXAlignment.Center
    gui.statusLabel.Parent = controlPanel
    
    -- Event Connections with Improved Functionality
    gui.closeButton.MouseButton1Click:Connect(function()
        cleanupDrawingElements()
        gui.screenGui:Destroy()
        state.guiVisible = false
    end)
    
    gui.minimizeButton.MouseButton1Click:Connect(function()
        state.guiMinimized = not state.guiMinimized
        local targetSize = state.guiMinimized and UDim2.new(0, 550, 0, 50) or UDim2.new(0, 550, 0, 450)
        
        tweenService:Create(gui.mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
            Size = targetSize
        }):Play()
        
        gui.minimizeButton.Text = state.guiMinimized and "â–¡" or "_"
        gui.contentFrame.Visible = not state.guiMinimized
        controlPanel.Visible = not state.guiMinimized
    end)
    
    -- Enhanced Toggle Button with Smooth Show/Hide
    gui.toggleButton.MouseButton1Click:Connect(function()
        state.linesEnabled = not state.linesEnabled
        
        -- Show/Hide persistent lines instead of destroying them
        for key, lineData in pairs(ui.persistentLines) do
            if lineData.line then
                pcall(function()
                    lineData.line.Visible = state.linesEnabled
                end)
            end
        end
        
        -- Show/Hide persistent dots
        for key, dotData in pairs(ui.persistentDots) do
            if dotData.dot then
                pcall(function()
                    dotData.dot.Visible = state.linesEnabled
                end)
            end
        end
        
        gui.toggleButton.Text = state.linesEnabled and "âœ“ Lines ON" or "âœ— Lines OFF"
        gui.toggleButton.BackgroundColor3 = state.linesEnabled and Color3.fromRGB(40, 167, 69) or Color3.fromRGB(220, 53, 69)
        
        -- Update status immediately
        local friendCount = 0
        for _ in pairs(state.friendData) do
            friendCount = friendCount + 1
        end
        local statusText = state.linesEnabled and "Lines: ON" or "Lines: OFF"
        gui.statusLabel.Text = "Friends: " .. friendCount .. " | " .. statusText
        
        print("Friend lines:", state.linesEnabled and "SHOWN" or "HIDDEN")
    end)
    
    discordButton.MouseButton1Click:Connect(function()
        setclipboard("https://discord.gg/PHxN8nadgk")
        discordButton.Text = "âœ“ Copied!"
        
        task.wait(2)
        discordButton.Text = "ðŸ“‹ Copy: discord.gg/PHxN8nadgk"
    end)
    
    -- Enhanced Status Update Loop
    task.spawn(function()
        while gui.screenGui and gui.screenGui.Parent do
            task.wait(1)
            if gui.statusLabel and gui.statusLabel.Parent then
                local friendCount = updateFriendList()
                local statusText = state.linesEnabled and "Lines: ON" or "Lines: OFF"
                gui.statusLabel.Text = "Friends: " .. friendCount .. " | " .. statusText
            end
        end
    end)
    
    print("Enhanced Clean GUI created successfully!")
end

-- Performance Monitoring
local function checkPerformance()
    local frameRate = 1 / runService.Heartbeat:Wait()
    if frameRate < 30 and not state.performanceMode then
        state.performanceMode = true
        config.updateRate = 0.2
        config.maxConnections = 25
        print("Performance mode enabled: Reduced connections")
    elseif frameRate > 45 and state.performanceMode then
        state.performanceMode = false
        config.updateRate = 0.1
        config.maxConnections = 50
        print("Performance mode disabled: Full connections")
    end
end

-- Input Handling
local function setupInputHandling()
    userInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == config.guiKeybind then
            if gui.screenGui then
                state.guiVisible = not state.guiVisible
                gui.screenGui.Enabled = state.guiVisible
                print("GUI:", state.guiVisible and "SHOWN" or "HIDDEN")
            end
        end
    end)
end

-- Enhanced Update Loop with Better Cleanup
local function startUpdateLoop()
    -- Main heartbeat for rendering
    local renderConnection = runService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - state.lastUpdate >= config.updateRate then
            state.lastUpdate = currentTime
            checkPerformance()
            
            -- Schedule cleanup if lines are disabled
            if not state.linesEnabled then
                scheduleCleanup()
            end
        end
    end)
    
    table.insert(ui.connections, renderConnection)
    
    -- Friend scanning loop
    task.spawn(function()
        while true do
            task.wait(5)
            scanForFriends()
        end
    end)
end

-- Complete Cleanup Function
local function cleanup()
    print("Cleaning up Friend Viewer...")
    
    cleanupDrawingElements()
    
    -- Clear all tracking data
    state.trackedPlayers = {}
    state.friendData = {}
    state.friendships = {}
    
    if gui.screenGui then
        gui.screenGui:Destroy()
    end
    
    print("Friend Viewer cleanup completed!")
end

-- Initialize
local function initialize()
    print("Initializing Enhanced Friend Viewer v5.0...")
    
    setupInputHandling()
    createCleanGUI()
    startUpdateLoop()
    scanForFriends()
    
    print("Enhanced Friend Viewer v5.0 initialized successfully!")
    print("Press", config.guiKeybind.Name, "to toggle GUI")
    print("Use GUI button to toggle friend lines")
    print("IMPROVEMENTS:")
    print("- Better line cleanup system")
    print("- Improved scrolling for 4+ friends") 
    print("- GUI-only line controls")
    print("- Performance optimizations")
end

-- Event Connections
players.PlayerAdded:Connect(function()
    task.wait(1)
    scanForFriends()
end)

players.PlayerRemoving:Connect(function(player)
    -- Clean up data for removed player
    for i = #state.friendships, 1, -1 do
        local friendship = state.friendships[i]
        if string.find(friendship, player.Name) then
            table.remove(state.friendships, i)
        end
    end
    
    for key in pairs(state.friendData) do
        if string.find(key, player.Name) then
            state.friendData[key] = nil
        end
    end
    
    for key in pairs(state.trackedPlayers) do
        if string.find(key, player.Name) then
            state.trackedPlayers[key] = nil
        end
    end
end)

-- Cleanup on script end
game:GetService("ScriptContext").Error:Connect(cleanup)

-- Auto-cleanup timer to prevent memory leaks
task.spawn(function()
    while true do
        task.wait(30) -- Clean up every 30 seconds
        if not state.linesEnabled then
            cleanupDrawingElements()
        end
    end
end)

-- Start the enhanced friend viewer
initialize()
